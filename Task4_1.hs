module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- Как и в 3_3 для имплементации функтора в качестве ограничейний используется следующие законы функтора

--      2 закона функтора
-- проход по функтору с помощью функции тождественного отображения возвращает неизменный функтор
--      fmap id = id

-- Если 2 последовательные операции обхода выподнятюся друг за другом,
-- то результат должен быть идентичен проходу 1-й композитной функции, которая состоит из этих двух
--      fmap (f . g)  ==  fmap f . fmap g

-- fmap
-- получении контейнера со значением ->
-- распаковка контейнера и добыча значения ->
-- примение к значению функции ->
-- запаковака значения обратно в контейнер

-- fmap :: (a -> b) -> f a -> f b

instance Functor FunMonad where
    fmap func (FunMonad fun) = FunMonad (func . fun)

-- аппликативный функтор - тоже самое, что и функтор, только функция которая применяется к значению в контейнере
-- сама находится в контейнере

-- (<*>) :: f (a -> b) -> f a -> f b

-- тип функции в FunMonad - String -> a.
-- При подстановке параметорв в фнукцию <*> произойдет следущее связывание.

-- (<*>) :: f (String -> a -> b) -> f(String -> a) -> f b

-- то есть чтобы получить на выходе (f b) нужно в левую и в правую функцию первым аргументом поставить строку,
-- затем ответ правой функции подставить во второй аргумет к левой функции.

--    законы аппликативного функора

-- pure id <*> v = v
-- pure f <*> pure x = pure (f x)
-- u <*> pure y = pure ($ y) <*> u
-- pure (.) <*> u <*> v <*> w = u <*> (v <*> w)

instance Applicative FunMonad where
    pure func = FunMonad (\arg -> func)
    (<*>) (FunMonad leftFun) (FunMonad rightFun) = FunMonad (\arg -> ((leftFun arg (rightFun arg))))

-- монада - развитие концепции апликативного функтора. Монада так же имеет функцию прохода по входному значению.
-- В отличие от функтора и аппликативного функтора, функция когорая изменяет значение самой монады возвращает уже завернутое в монаду значение.

-- (>>=) :: m a -> (a -> m b) -> m b

-- после подстановки FunMonad тип функции становится следующим
-- (>>=) :: m (String -> a) -> ((String -> a) -> m b) -> m b

--  Для получения монады на выходе нужно применить к правой функции левую функцию с аргументом строки.
--  (rightFunc (leftFunc "qwe")) - такой вид ответа не подразумевает динамического аргумента строки.
--  Чтобы сделать аргумент динамическим, нужно взять значение монады - поместить это значение в новую монаду
--  и применить аргумент, который можно передавать параметорм к функции.
--  FunMonad (\arg -> fun (rightFunc (leftFunc arg)) arg)

instance Monad FunMonad where
    return func = FunMonad (\arg -> func)
    (>>=) (FunMonad leftFunc) rightFunc = FunMonad (\arg -> fun (rightFunc (leftFunc arg)) arg)

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`
